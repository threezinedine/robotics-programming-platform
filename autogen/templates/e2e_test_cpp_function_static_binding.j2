{% for method in class.methods %}
{% if "e2e" in method.annotations and method.isStatic and method.access == "public" %}
static PyObject* {{ method.name }}(PyObject* self, PyObject* args)
{
    {% for param in method.parameters %}
    {{ param.type.replace("const", "").replace("*", "").replace("&", "").replace("std::string", "const char*").replace("String", "const char*") }} {{ param.name }};
    {% endfor %}

    if (!PyArg_ParseTuple(args, "{{convertAllFunctionParametersToE2EBindingTypeList(method)}}"{% for param in method.parameters %}, &{{ param.name }}{% endfor %}))
    {
        return nullptr;
    }

    {% if method.returnType != "void" %}
        {% if e2eBindingType(method.returnType) == "s" %}
            {% if method.returnType in ["std::string", "const std::string&"] %}
                {% set addingSufix = ".c_str()" %}
            {% elif method.returnType in ["String", "const String&"] %}
                {% set addingSufix = ".CStr()" %}
            {% else %}
                {% set addingSufix = "" %}
            {% endif %}
        {% endif %}
    auto result = ::rpp::{{ class.name }}::{{ method.name }}({{ methodParametersCall(method, False) }});
    return Py_BuildValue("{{e2eBindingType(method.returnType)}}", result{{ addingSufix }});
    {% else %}
    ::rpp::{{ class.name }}::{{ method.name }}({{ methodParametersCall(method, False) }});
    Py_RETURN_NONE;
    {% endif %}
}
{% endif %}
{% endfor %}